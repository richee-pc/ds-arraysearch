<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì•Œê³ ë¦¬ì¦˜ íƒí—˜: ì •ë ¬ê³¼ íƒìƒ‰</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', sans-serif; }
        .bar, .sub-bar { transition: all 0.3s ease-in-out; }
        .nav-item { transition: all 0.2s ease; }
        .nav-item.active { color: #4f46e5; border-bottom-color: #4f46e5; }
        .tab-item.active { border-color: #4f46e5; color: #4f46e5; background-color: #eef2ff; }
        .log-item.active { background-color: #dbeafe; }
        
        /* ì‹œê°í™” ê°•í™” ìŠ¤íƒ€ì¼ */
        .viz-container { position: relative; min-height: 200px; }
        .merge-level { display: flex; justify-content: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;}
        .sub-array { display: flex; gap: 2px; padding: 5px; background-color: #e0e7ff; border-radius: 5px; border: 1px solid #c7d2fe; }
        .sub-bar { width: 2rem; text-align: center; color: white; background-color: #818cf8; border-radius: 3px; }
        .quick-partition { border: 2px dashed #a78bfa; border-radius: 5px; padding: 4px 0; margin-bottom: 5px;}
        .shell-gap-group { opacity: 0.3; }
        .shell-gap-group.active { opacity: 1; }

        /* í•´ì‹± ì‹œë®¬ë ˆì´í„° ìŠ¤íƒ€ì¼ */
        .hash-table { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 8px; }
        .hash-slot { border: 1px solid #cbd5e1; border-radius: 4px; padding: 8px; text-align: center; background: #f1f5f9; min-height: 60px; position: relative; }
        .hash-slot .slot-index { font-size: 0.75rem; color: #64748b; position: absolute; top: 2px; left: 4px; }
        .hash-slot.comparing { background-color: #fef9c3; border-color: #facc15; }
        .hash-slot.occupied { background-color: #e0e7ff; border-color: #818cf8; }
        .hash-slot.collided { background-color: #fee2e2; border-color: #f87171; }
        .chain-item { background-color: #60a5fa; color: white; padding: 2px 4px; border-radius: 3px; margin-top: 4px; font-size: 0.875rem; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <!-- Header -->
    <header class="bg-white shadow-md sticky top-0 z-50">
        <nav class="container mx-auto px-6 py-4 flex justify-between items-center">
            <h1 class="text-2xl font-bold text-indigo-600 cursor-pointer" onclick="showPage('home')">ğŸš€ ì•Œê³ ë¦¬ì¦˜ íƒí—˜</h1>
            <div class="flex space-x-4 text-md md:text-lg">
                <a href="#sorting" class="text-slate-600 hover:text-indigo-600" onclick="showPage('sorting')">ì •ë ¬ ì•Œê³ ë¦¬ì¦˜</a>
                <a href="#searching" class="text-slate-600 hover:text-indigo-600" onclick="showPage('searching')">íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜</a>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 md:p-8">
        <!-- Home Page -->
        <div id="home-page" class="page">
             <div class="text-center bg-white p-12 rounded-xl shadow-lg">
                <h2 class="text-4xl font-bold mb-4">ì•Œê³ ë¦¬ì¦˜ íƒí—˜: ì •ë ¬ê³¼ íƒìƒ‰ì˜ ì„¸ê³„ë¡œ!</h2>
                <p class="text-xl text-slate-600 max-w-3xl mx-auto mb-8">ë³µì¡í•´ ë³´ì´ëŠ” ì •ë ¬ê³¼ íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜, ëˆˆìœ¼ë¡œ ì§ì ‘ ë³´ë©° ì›ë¦¬ë¥¼ ê¹¨ìš°ì³ë´ìš”! ì½”ë”©ì˜ ì²«ê±¸ìŒì„ ë‚´ë”›ëŠ” ì—¬ëŸ¬ë¶„ì„ ìœ„í•œ ìµœê³ ì˜ ë†€ì´í„°ì…ë‹ˆë‹¤.</p>
                <div class="bg-indigo-50 p-8 rounded-lg mb-10 text-left max-w-2xl mx-auto">
                    <h3 class="text-2xl font-bold mb-4 text-indigo-700">ğŸ¯ í•™ìŠµ ëª©í‘œ</h3>
                    <ul class="space-y-3 text-lg text-slate-700 list-disc list-inside">
                        <li>ë‹¨ìˆœ ì •ë ¬(ë²„ë¸”, ì„ íƒ, ì‚½ì…)ê³¼ ë³µì¡í•˜ì§€ë§Œ íš¨ìœ¨ì ì¸ ì •ë ¬(ì‰˜, í•©ë³‘, í€µ, ê¸°ìˆ˜)ì˜ ë™ì‘ ì›ë¦¬ë¥¼ ì‹œê°ì ìœ¼ë¡œ ì´í•´í•œë‹¤.</li>
                        <li>ë‹¤ì–‘í•œ íƒìƒ‰(ìˆœì°¨, ì´ì§„, ë³´ê°„ ë“±) ì•Œê³ ë¦¬ì¦˜ì˜ ì°¨ì´ì ì„ ëª…í™•íˆ íŒŒì•…í•˜ê³  í•´ì‹±ì˜ ê°œë…ì„ ì´í•´í•œë‹¤.</li>
                        <li>ì•Œê³ ë¦¬ì¦˜ì˜ íš¨ìœ¨ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” 'ì‹œê°„ ë³µì¡ë„'ì˜ ê¸°ë³¸ ê°œë…ì„ ìµíŒë‹¤.</li>
                    </ul>
                </div>
                <div class="flex justify-center gap-6">
                    <button onclick="showPage('sorting')" class="bg-indigo-600 text-white font-bold py-3 px-8 rounded-lg text-xl hover:bg-indigo-700 transition-transform transform hover:scale-105">ì •ë ¬ ë°°ìš°ëŸ¬ ê°€ê¸°</button>
                    <button onclick="showPage('searching')" class="bg-teal-500 text-white font-bold py-3 px-8 rounded-lg text-xl hover:bg-teal-600 transition-transform transform hover:scale-105">íƒìƒ‰ ë°°ìš°ëŸ¬ ê°€ê¸°</button>
                </div>
            </div>
        </div>

        <!-- Sorting Algorithms Page -->
        <div id="sorting-page" class="page hidden">
            <nav id="sorting-nav" class="flex flex-wrap justify-center border-b-2 mb-8">
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="bubbleSort">ë²„ë¸” ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="selectionSort">ì„ íƒ ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="insertionSort">ì‚½ì… ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="shellSort">ì‰˜ ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="mergeSort">í•©ë³‘ ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="quickSort">í€µ ì •ë ¬</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="radixSort">ê¸°ìˆ˜ ì •ë ¬</button>
            </nav>
            <div id="algorithm-content"></div>
        </div>

        <!-- Searching Algorithms Page -->
        <div id="searching-page" class="page hidden">
            <nav id="searching-nav" class="flex flex-wrap justify-center border-b-2 mb-8">
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="sequentialSearch">ìˆœì°¨ íƒìƒ‰</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="binarySearch">ì´ì§„ íƒìƒ‰</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="interpolationSearch">ë³´ê°„ íƒìƒ‰</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="indexedSequentialSearch">ìƒ‰ì¸ ìˆœì°¨ íƒìƒ‰</button>
                <button class="nav-item text-lg font-semibold p-3 border-b-4 border-transparent" data-algo="hashing">í•´ì‹±</button>
            </nav>
            <div id="search-algorithm-content"></div>
        </div>
    </main>

    <script>
        // --- Global State ---
        let currentAlgorithm = null;
        let animationState = {
            isPlaying: false,
            isPaused: false,
            steps: [],
            currentStep: 0,
            speed: 500, // ms
            timeoutId: null,
        };

        // --- Data & Content ---
        const algorithms = {
            // --- ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ---
            bubbleSort: {
                name: "ë²„ë¸” ì •ë ¬ (Bubble Sort)", type: 'sort',
                idea: "ì¸ì ‘í•œ 2ê°œì˜ ë ˆì½”ë“œë¥¼ ë¹„êµí•˜ì—¬ ìˆœì„œëŒ€ë¡œ ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ì„œë¡œ êµí™˜í•©ë‹ˆë‹¤.",
                analogy: "ì—¬ëŸ¬ ëª…ì˜ í•™ìƒë“¤ì´ í‚¤ ìˆœì„œëŒ€ë¡œ ì¤„ì„ ì„œëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ë§¨ ì•ë¶€í„° ë‘ ëª…ì”© ì§ì„ ì§€ì–´ í‚¤ë¥¼ ë¹„êµí•˜ê³ , í‚¤ê°€ ë” í° í•™ìƒì„ ë’¤ë¡œ ë³´ë‚´ëŠ” ê³¼ì •ì„ ì¤„ ëê¹Œì§€ ë°˜ë³µí•˜ëŠ” ê±°ì£ . ì´ ê³¼ì •ì„ ëª¨ë“  í•™ìƒì´ ì œìë¦¬ë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ê³„ì†í•˜ëŠ” ê±°ì˜ˆìš”. ë§ˆì¹˜ ë¬¼ì†ì˜ ê±°í’ˆ(Bubble)ì´ ë³´ê¸€ë³´ê¸€ ìœ„ë¡œ ì˜¬ë¼ì˜¤ëŠ” ëª¨ìŠµê³¼ ë¹„ìŠ·í•´ì„œ ë²„ë¸” ì •ë ¬ì´ë¼ëŠ” ì´ë¦„ì´ ë¶™ì—ˆë‹µë‹ˆë‹¤.",
                defaultInput: "5, 2, 8, 1, 9",
                performance: { best: { notation: "O(n)" }, average: { notation: "O(nÂ²)" }, worst: { notation: "O(nÂ²)" } },
                code: { c: `void swap(int* xp, int* yp) { int temp = *xp; *xp = *yp; *yp = temp; }

void bubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) { 
                swap(&arr[j], &arr[j + 1]); 
            }
        }
    }
}` }
            },
            selectionSort: {
                name: "ì„ íƒ ì •ë ¬ (Selection Sort)", type: 'sort',
                idea: "ì „ì²´ ë°ì´í„° ì¤‘ì—ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ì°¾ì•„ì„œ ì •ë ¬ë˜ì§€ ì•Šì€ ë¶€ë¶„ì˜ ì²« ë²ˆì§¸ ë°ì´í„°ì™€ êµí™˜í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤.",
                analogy: "ì—¬ëŸ¬ ê°œì˜ ê³µ ì¤‘ì—ì„œ ê°€ì¥ ê°€ë²¼ìš´ ê³µì„ ê³¨ë¼ë‚´ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ëª¨ë“  ê³µì˜ ë¬´ê²Œë¥¼ í•œ ë²ˆì”© ë‹¤ ì¬ë³´ê³  ê°€ì¥ ê°€ë²¼ìš´ ê³µì„ ì°¾ì•„ ë§¨ ì™¼ìª½ì— ë†“ìŠµë‹ˆë‹¤. ê·¸ë‹¤ìŒ, ë‚¨ì€ ê³µë“¤ ì¤‘ì—ì„œ ë‹¤ì‹œ ê°€ì¥ ê°€ë²¼ìš´ ê³µì„ ì°¾ì•„ ë‘ ë²ˆì§¸ ìë¦¬ì— ë†“ëŠ” ê³¼ì •ì„ ëª¨ë“  ê³µì´ ìˆœì„œëŒ€ë¡œ ë†“ì¼ ë•Œê¹Œì§€ ë°˜ë³µí•˜ëŠ” ê±°ì£ .",
                defaultInput: "64, 25, 12, 22, 11",
                performance: { best: { notation: "O(nÂ²)" }, average: { notation: "O(nÂ²)" }, worst: { notation: "O(nÂ²)" } },
                code: { c: `void swap(int* xp, int* yp) { int temp = *xp; *xp = *yp; *yp = temp; }

void selectionSort(int arr[], int n) {
    int i, j, min_idx;
    for (i = 0; i < n - 1; i++) {
        min_idx = i;
        for (j = i + 1; j < n; j++) {
            if (arr[j] < arr[min_idx]) 
                min_idx = j;
        }
        swap(&arr[min_idx], &arr[i]);
    }
}` }
            },
            insertionSort: {
                name: "ì‚½ì… ì •ë ¬ (Insertion Sort)", type: 'sort',
                idea: "ì •ë ¬ë˜ì–´ ìˆëŠ” ë¶€ë¶„ì— ìƒˆë¡œìš´ ë ˆì½”ë“œë¥¼ ì˜¬ë°”ë¥¸ ìœ„ì¹˜ì— ì‚½ì…í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤.",
                analogy: "ì†ì— ë“¤ê³  ìˆëŠ” ì¹´ë“œë¥¼ ìˆ«ì ìˆœì„œëŒ€ë¡œ ì •ë¦¬í•˜ëŠ” ê²ƒê³¼ ë˜‘ê°™ì•„ìš”. ìƒˆë¡œìš´ ì¹´ë“œë¥¼ ë½‘ì„ ë•Œë§ˆë‹¤, ì´ë¯¸ ì†ì— ë“¤ê³  ìˆëŠ” ì •ë ¬ëœ ì¹´ë“œë“¤ê³¼ ë¹„êµí•´ì„œ ì˜¬ë°”ë¥¸ ìë¦¬ì— ì™ ë¼ì›Œ ë„£ì–ì•„ìš”? ê·¸ ê³¼ì •ì„ ëª¨ë“  ì¹´ë“œë¥¼ ë‹¤ ë½‘ì„ ë•Œê¹Œì§€ ë°˜ë³µí•˜ëŠ” ê±°ì˜ˆìš”.",
                defaultInput: "12, 11, 13, 5, 6",
                performance: { best: { notation: "O(n)" }, average: { notation: "O(nÂ²)" }, worst: { notation: "O(nÂ²)" } },
                code: { c: `void insertionSort(int arr[], int n) {
    int i, key, j;
    for (i = 1; i < n; i++) {
        key = arr[i];
        j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
}` }
            },
            shellSort: {
                name: "ì‰˜ ì •ë ¬ (Shell Sort)", type: 'sort',
                idea: "ì „ì²´ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¼ì •í•œ ê°„ê²©(gap)ì˜ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¡œ ë‚˜ëˆˆ í›„, ê° ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚½ì… ì •ë ¬í•˜ì—¬ ì •ë ¬í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤. ê°„ê²©ì€ ì ì  ì¤„ì—¬ë‚˜ê°‘ë‹ˆë‹¤.",
                analogy: "ì¹´ë“œ ì •ë¦¬ë¥¼ ë” ë¹ ë¥´ê²Œ í•˜ëŠ” ë°©ë²•ì´ì—ìš”. ì²˜ìŒì—ëŠ” 10ì¥ì”© ë„ì—„ë„ì—„ ì¹´ë“œë¥¼ ë¹„êµí•´ì„œ ëŒ€ì¶© ì •ë ¬í•˜ê³ , ë‹¤ìŒì—” 5ì¥ì”©, ê·¸ ë‹¤ìŒì—” 2ì¥ì”©... ì´ë ‡ê²Œ ê°„ê²©ì„ ì¤„ì—¬ê°€ë©° ì •ë ¬í•˜ë©´ ë§ˆì§€ë§‰ì— ê±°ì˜ ì •ë ¬ëœ ìƒíƒœê°€ ë˜ì–´ì„œ ì‚½ì… ì •ë ¬ì´ ì•„ì£¼ ë¹ ë¥´ê²Œ ëë‚˜ìš”.",
                defaultInput: "12, 34, 54, 2, 3, 40, 22, 88, 60",
                performance: { best: { notation: "O(n log n)" }, average: { notation: "O(n^(3/2))" }, worst: { notation: "O(nÂ²)" } },
                code: { c: `void shellSort(int arr[], int n) {
    for (int gap = n / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < n; i += 1) {
            int temp = arr[i];
            int j;
            for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {
                arr[j] = arr[j - gap];
            }
            arr[j] = temp;
        }
    }
}` }
            },
            mergeSort: {
                name: "í•©ë³‘ ì •ë ¬ (Merge Sort)", type: 'sort',
                idea: "ë¶„í•  ì •ë³µ(Divide and Conquer) ë°©ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ë¥¼ ë‘ ê°œì˜ ê· ë“±í•œ í¬ê¸°ë¡œ ë¶„í• í•˜ê³  ë¶„í• ëœ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë ¬í•œ ë‹¤ìŒ, ì •ë ¬ëœ ë‘ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¥¼ í•©í•˜ì—¬(merge) ì „ì²´ë¥¼ ì •ë ¬í•©ë‹ˆë‹¤.",
                analogy: "ì–´ë ¤ìš´ ì‹œí—˜ê³µë¶€ë¥¼ í•  ë•Œ ë²”ìœ„ë¥¼ ë°˜ìœ¼ë¡œ ë‚˜ëˆ„ê³ , ë˜ ë°˜ìœ¼ë¡œ ë‚˜ëˆ ì„œ ì‘ì€ ë¶€ë¶„ë¶€í„° ì™„ë²½í•˜ê²Œ ê³µë¶€í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ì‘ì€ ë¶€ë¶„ë“¤ì„ ë‹¤ ê³µë¶€í•œ ë’¤ì— í•©ì³ì„œ ì „ì²´ë¥¼ ë³´ë©´ ì–´ëŠìƒˆ ì •ë¦¬ê°€ ëë‚˜ìˆëŠ” ê±°ì£ . ë¶„í• í•´ì„œ ì •ë³µí•˜ëŠ” ì „ëµì´ì—ìš”!",
                defaultInput: "27, 10, 12, 20, 25, 13, 15, 22",
                performance: { best: { notation: "O(n log n)" }, average: { notation: "O(n log n)" }, worst: { notation: "O(n log n)" } },
                code: { c: `void merge(int arr[], int l, int m, int r) { /* ... */ }

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}` }
            },
            quickSort: {
                name: "í€µ ì •ë ¬ (Quick Sort)", type: 'sort',
                idea: "ë¶„í•  ì •ë³µ ë°©ë²•ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ì—ì„œ í•˜ë‚˜ì˜ ê¸°ì¤€(pivot)ì„ ê³ ë¥´ê³ , í”¼ë²—ë³´ë‹¤ ì‘ì€ ê°’ì€ ì™¼ìª½, í° ê°’ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë¶„í• í•œ í›„, ê° ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ë¥¼ ì¬ê·€ì ìœ¼ë¡œ ì •ë ¬í•©ë‹ˆë‹¤.",
                analogy: "ë‹¨ì²´ ì‚¬ì§„ì„ ì°ì„ ë•Œ í‚¤ ìˆœìœ¼ë¡œ ì„¸ìš°ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ê¸°ì¤€ì´ ë  í•™ìƒ(pivot)ì„ í•œ ëª… ë½‘ê³ , ê·¸ í•™ìƒë³´ë‹¤ ì‘ì€ ì¹œêµ¬ë“¤ì€ ì™¼ìª½, í° ì¹œêµ¬ë“¤ì€ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë³´ë‚´ìš”. ê·¸ë¦¬ê³  ì™¼ìª½ ê·¸ë£¹ê³¼ ì˜¤ë¥¸ìª½ ê·¸ë£¹ì—ì„œ ê°ê° ê°™ì€ ë°©ë²•ìœ¼ë¡œ ê¸°ì¤€ì„ ë½‘ì•„ ì¤„ì„ ì„¸ìš°ë©´ ì „ì²´ ì¤„ì´ ìˆœì‹ê°„ì— ì™„ì„±ë˜ì£ .",
                defaultInput: "5, 3, 8, 4, 9, 1, 6, 2, 7",
                performance: { best: { notation: "O(n log n)" }, average: { notation: "O(n log n)" }, worst: { notation: "O(nÂ²)" } },
                code: { c: `void swap(int* a, int* b) { /* ... */ }
int partition(int arr[], int low, int high) {
    int pivot = arr[low];
    int i = high + 1;

    for (int j = high; j > low; j--) {
        if (arr[j] > pivot) {
            i--;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i - 1], &arr[low]);
    return (i - 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}` }
            },
            radixSort: {
                name: "ê¸°ìˆ˜ ì •ë ¬ (Radix Sort)", type: 'sort',
                idea: "ê°’ì„ ë¹„êµí•˜ì§€ ì•Šê³ , ë°ì´í„°ì˜ ìë¦¿ìˆ˜(radix)ë¥¼ ì´ìš©í•˜ì—¬ ì •ë ¬í•©ë‹ˆë‹¤. 1ì˜ ìë¦¬ë¶€í„° ê°€ì¥ í° ìë¦¿ìˆ˜ê¹Œì§€ ìˆœì„œëŒ€ë¡œ ë²„í‚·ì— ë°ì´í„°ë¥¼ ë„£ì—ˆë‹¤ ë¹¼ëŠ” ê³¼ì •ì„ ë°˜ë³µí•©ë‹ˆë‹¤.",
                analogy: "ìˆ«ì ì¹´ë“œë“¤ì„ 0ë¶€í„° 9ê¹Œì§€ ì“°ì¸ ìƒì(ë²„í‚·)ì— ì •ë¦¬í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ë¨¼ì € ëª¨ë“  ì¹´ë“œë¥¼ 1ì˜ ìë¦¿ìˆ˜ì— ë§ì¶° ìƒìì— ë„£ê³  ìˆœì„œëŒ€ë¡œ êº¼ë‚´ìš”. ê·¸ ë‹¤ìŒì—” 10ì˜ ìë¦¿ìˆ˜ì— ë§ì¶° ê°™ì€ ê³¼ì •ì„ ë°˜ë³µí•˜ì£ . ì´ë ‡ê²Œ í•˜ë©´ ëª¨ë“  ì¹´ë“œê°€ ì™„ë²½í•˜ê²Œ ì •ë ¬ë©ë‹ˆë‹¤.",
                defaultInput: "170, 45, 75, 90, 802, 24, 2, 66",
                performance: { best: { notation: "O(nk)" }, average: { notation: "O(nk)" }, worst: { notation: "O(nk)" } },
                code: { c: `int getMax(int arr[], int n) { /* ... */ }
void countSort(int arr[], int n, int exp) { /* ... */ }

void radixsort(int arr[], int n) {
    int m = getMax(arr, n);
    for (int exp = 1; m / exp > 0; exp *= 10)
        countSort(arr, n, exp);
}` }
            },
            // --- íƒìƒ‰ ì•Œê³ ë¦¬ì¦˜ ---
            sequentialSearch: {
                name: "ìˆœì°¨ íƒìƒ‰ (Sequential Search)", type: 'search',
                idea: "ì •ë ¬ë˜ì§€ ì•Šì€ ë°°ì—´ì„ ì²˜ìŒë¶€í„° ë§ˆì§€ë§‰ê¹Œì§€ í•˜ë‚˜ì”© ê²€ì‚¬í•˜ëŠ” ê°€ì¥ ê°„ë‹¨í•˜ê³  ì§ì ‘ì ì¸ íƒìƒ‰ ë°©ë²•ì…ë‹ˆë‹¤.",
                analogy: "ë„ì„œê´€ì—ì„œ ì±… ì œëª©ë§Œ ë³´ê³  ì›í•˜ëŠ” ì±…ì„ ì°¾ì„ ë•Œ, ì²« ë²ˆì§¸ ì±…ê½‚ì´ì˜ ì²« ë²ˆì§¸ ì±…ë¶€í„° ë§ˆì§€ë§‰ ì±…ê¹Œì§€ í•˜ë‚˜ë„ ë¹ ì§ì—†ì´ í›‘ì–´ë³´ëŠ” ê²ƒê³¼ ê°™ì•„ìš”.",
                defaultInput: "9, 2, 8, 5, 7, 1, 6", defaultTarget: "7",
                performance: { best: { notation: "O(1)" }, average: { notation: "O(n)" }, worst: { notation: "O(n)" } },
                code: { c: `int sequentialSearch(int arr[], int n, int key) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == key) {
            return i; // íƒìƒ‰ ì„±ê³µ
        }
    }
    return -1; // íƒìƒ‰ ì‹¤íŒ¨
}` }
            },
            binarySearch: {
                name: "ì´ì§„ íƒìƒ‰ (Binary Search)", type: 'search',
                idea: "ì •ë ¬ëœ ë°°ì—´ì˜ ì¤‘ì•™ì— ìˆëŠ” ê°’ì„ ì¡°ì‚¬í•˜ì—¬ ì°¾ê³ ì í•˜ëŠ” í•­ëª©ì´ ì™¼ìª½ ë˜ëŠ” ì˜¤ë¥¸ìª½ ë¶€ë¶„ ë°°ì—´ì— ìˆëŠ”ì§€ë¥¼ ì•Œì•„ë‚´ì–´ íƒìƒ‰ì˜ ë²”ìœ„ë¥¼ ë°˜ìœ¼ë¡œ ì¤„ì—¬ê°€ë©° íƒìƒ‰ì„ ì§„í–‰í•©ë‹ˆë‹¤.",
                analogy: "ì˜ì–´ ì‚¬ì „ì—ì„œ ë‹¨ì–´ë¥¼ ì°¾ì„ ë•Œ, ì‚¬ì „ì„ ì•„ë¬´ ë°ë‚˜ í¼ì³ì„œ ì¤‘ê°„ ë‹¨ì–´ì™€ ë¹„êµí•˜ì—¬ ì•ë’¤ ë²”ìœ„ë¥¼ ì¤„ì—¬ë‚˜ê°€ëŠ” ê²ƒê³¼ ê°™ì•„ìš”.",
                defaultInput: "1, 2, 5, 6, 7, 8, 9", defaultTarget: "2",
                performance: { best: { notation: "O(1)" }, average: { notation: "O(log n)" }, worst: { notation: "O(log n)" } },
                code: { c: `int binarySearch(int arr[], int l, int r, int key) {
    while (l <= r) {
        int m = l + (r - l) / 2;
        if (arr[m] == key) return m;
        if (arr[m] < key) l = m + 1;
        else r = m - 1;
    }
    return -1;
}` }
            },
            interpolationSearch: {
                name: "ë³´ê°„ íƒìƒ‰ (Interpolation Search)", type: 'search',
                idea: "íƒìƒ‰ í‚¤ê°€ ì¡´ì¬í•  ìœ„ì¹˜ë¥¼ ì˜ˆì¸¡í•˜ì—¬ íƒìƒ‰í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ, ë°ì´í„°ê°€ ê· ë“±í•˜ê²Œ ë¶„í¬ë˜ì–´ ìˆì„ ë•Œ ì´ì§„ íƒìƒ‰ë³´ë‹¤ íš¨ìœ¨ì ì…ë‹ˆë‹¤.",
                analogy: "ì „í™”ë²ˆí˜¸ë¶€ì—ì„œ 'í™ê¸¸ë™'ì„ ì°¾ì„ ë•Œ, ì¤‘ê°„ì¸ 'ì‚¬'ì”¨ë¶€í„° ì°¾ì§€ ì•Šê³  ëë¶€ë¶„ì¸ 'í•˜'ì”¨ ê·¼ì²˜ë¥¼ í¼ì³ë³´ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ë°ì´í„°ì˜ ë¶„í¬ë¥¼ ì˜ˆì¸¡í•´ì„œ ë” ë˜‘ë˜‘í•˜ê²Œ ì¤‘ê°„ ì§€ì ì„ ì •í•˜ëŠ” ê±°ì£ .",
                defaultInput: "10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47", defaultTarget: "18",
                performance: { best: { notation: "O(1)" }, average: { notation: "O(log log n)" }, worst: { notation: "O(n)" } },
                code: { c: `int interpolationSearch(int arr[], int n, int key) {
    int lo = 0, hi = (n - 1);
    while (lo <= hi && key >= arr[lo] && key <= arr[hi]) {
        if (lo == hi) {
            if (arr[lo] == key) return lo;
            return -1;
        }
        int pos = lo + (((double)(hi - lo) / 
              (arr[hi] - arr[lo])) * (key - arr[lo]));
        if (arr[pos] == key) return pos;
        if (arr[pos] < key) lo = pos + 1;
        else hi = pos - 1;
    }
    return -1;
}` }
            },
            indexedSequentialSearch: {
                name: "ìƒ‰ì¸ ìˆœì°¨ íƒìƒ‰", type: 'conceptual',
                idea: "ì¸ë±ìŠ¤ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ íƒìƒ‰ íš¨ìœ¨ì„ ì¦ëŒ€ì‹œí‚µë‹ˆë‹¤. ì£¼ ìë£Œ ë¦¬ìŠ¤íŠ¸ì™€ ì¸ë±ìŠ¤ í…Œì´ë¸”ì€ ëª¨ë‘ ì •ë ¬ë˜ì–´ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.",
                analogy: "ì±…ì˜ ë§¨ ë’¤ì— ìˆëŠ” 'ì°¾ì•„ë³´ê¸°(ìƒ‰ì¸)'ë¥¼ ì´ìš©í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ì±… ì „ì²´ë¥¼ ë‹¤ ë’¤ì§€ëŠ” ëŒ€ì‹ , ìƒ‰ì¸ì—ì„œ ì›í•˜ëŠ” í‚¤ì›Œë“œê°€ ëª‡ í˜ì´ì§€ì— ìˆëŠ”ì§€ ë¨¼ì € ì°¾ê³  ê·¸ í˜ì´ì§€ë¡œ ë°”ë¡œ ë„˜ì–´ê°€ëŠ” ê±°ì£ .",
                performanceText: "ì¸ë±ìŠ¤ í…Œì´ë¸” í¬ê¸°ê°€ m, ì£¼ ìë£Œ ë¦¬ìŠ¤íŠ¸ í¬ê¸°ê°€ nì¼ ë•Œ, ë³µì¡ë„ëŠ” O(m+n/m) ì…ë‹ˆë‹¤.",
                code: { c: `// ê°œë… ì„¤ëª…ì„ ìœ„í•œ ì˜ì‚¬ì½”ë“œì…ë‹ˆë‹¤.
// 1. ì¸ë±ìŠ¤ í…Œì´ë¸”ì—ì„œ keyê°€ ì†í•  ë²”ìœ„ë¥¼ ì°¾ëŠ”ë‹¤.
//    (index_table[i] <= key < index_table[i+1])
//
// 2. í•´ë‹¹ ë²”ìœ„ì˜ ì£¼ ìë£Œ ë¦¬ìŠ¤íŠ¸ ë¸”ë¡ì„ ê°€ì ¸ì˜¨ë‹¤.
//
// 3. í•´ë‹¹ ë¸”ë¡ ë‚´ì—ì„œ ìˆœì°¨ íƒìƒ‰ì„ ìˆ˜í–‰í•˜ì—¬ keyë¥¼ ì°¾ëŠ”ë‹¤.` },
                visualization: `<div class="text-center p-4">
                    <h4 class="font-bold text-lg mb-2">ì±…ì˜ 'ì°¾ì•„ë³´ê¸°'ì™€ ê°™ì€ ì›ë¦¬</h4>
                    <div class="flex flex-col md:flex-row justify-center items-start gap-4">
                        <div class="bg-blue-100 p-4 rounded-lg">
                            <h5 class="font-bold mb-2">ì¸ë±ìŠ¤ í…Œì´ë¸”</h5>
                            <p>[ê°€] - 1 page</p>
                            <p>[ë‚˜] - 50 page</p>
                            <p>[ë‹¤] - 120 page</p>
                            <p>...</p>
                        </div>
                        <div class="text-2xl mt-8">â†’</div>
                        <div class="bg-green-100 p-4 rounded-lg">
                            <h5 class="font-bold mb-2">ì£¼ ë°ì´í„° (ì±… ë‚´ìš©)</h5>
                            <p>1~49 page ë‚´ìš©</p>
                            <p class="font-bold bg-yellow-200">50~119 page ë‚´ìš© (íƒìƒ‰ ë²”ìœ„)</p>
                            <p>120~... page ë‚´ìš©</p>
                        </div>
                    </div>
                    <p class="mt-4 text-slate-600">ë¨¼ì € ì¸ë±ìŠ¤ì—ì„œ ë²”ìœ„ë¥¼ ì°¾ê³ , í•´ë‹¹ ë²”ìœ„ë§Œ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•˜ì—¬ íš¨ìœ¨ì„ ë†’ì…ë‹ˆë‹¤.</p>
                </div>`
            },
            hashing: {
                name: "í•´ì‹± (Hashing)", type: 'conceptual-container',
                idea: "í‚¤ ê°’ì— ëŒ€í•œ ì‚°ìˆ ì  ì—°ì‚°(í•´ì‹œ í•¨ìˆ˜)ì— ì˜í•´ í…Œì´ë¸”ì˜ ì£¼ì†Œë¥¼ ê³„ì‚°í•˜ì—¬ í•­ëª©ì— ì ‘ê·¼í•©ë‹ˆë‹¤.",
                analogy: "ëª¨ë“  ì‚¬ëŒì—ê²Œ ê³ ìœ í•œ 'ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸'ë¥¼ ë¶€ì—¬í•˜ëŠ” ê²ƒê³¼ ê°™ì•„ìš”. ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸(í•´ì‹œ ê°’)ë¥¼ ì•Œë©´ ë°”ë¡œ ê·¸ ì‚¬ëŒì˜ ì •ë³´(ë°ì´í„°)ë¥¼ ì°¾ì„ ìˆ˜ ìˆì£ .",
                subAlgos: {
                    linearProbing: {
                        name: "ì„ í˜• ì¡°ì‚¬ë²•",
                        idea: "ì¶©ëŒì´ ë°œìƒí•˜ë©´, í•´ë‹¹ ìœ„ì¹˜ì—ì„œ ìˆœì°¨ì ìœ¼ë¡œ ë‹¤ìŒ ë¹ˆì¹¸ì„ ì°¾ì•„ ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.",
                        defaultInput: "8, 1, 9, 6, 13", tableSize: 7,
                        code: `// ì½”ë“œëŠ” ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤.`
                    },
                    quadraticProbing: {
                        name: "ì´ì°¨ ì¡°ì‚¬ë²•",
                        idea: "ì¶©ëŒì´ ë°œìƒí•˜ë©´, 1Â², 2Â², 3Â²... ë§Œí¼ ë–¨ì–´ì§„ ì¹¸ì„ ìˆœì„œëŒ€ë¡œ ì°¾ì•„ ë°ì´í„°ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.",
                        defaultInput: "8, 1, 9, 6, 13", tableSize: 7,
                        code: `// ì½”ë“œëŠ” ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤.`
                    },
                    doubleHashing: {
                        name: "ì´ì¤‘ í•´ì‹±",
                        idea: "ì¶©ëŒì´ ë°œìƒí•˜ë©´, ë‘ ë²ˆì§¸ í•´ì‹œ í•¨ìˆ˜ë¥¼ ì´ìš©í•´ ë‹¤ìŒ ìœ„ì¹˜ì˜ ê°„ê²©ì„ ì •í•œ ë’¤ ë¹ˆì¹¸ì„ ì°¾ì•„ ì €ì¥í•©ë‹ˆë‹¤.<br><b>- 2ì°¨ í•´ì‹œ í•¨ìˆ˜: h'(k) = 5 - (k % 5)</b><br><b>- ë‹¤ìŒ ìœ„ì¹˜: (h(k) + i * h'(k)) % í…Œì´ë¸” í¬ê¸°</b>",
                        defaultInput: "8, 1, 9, 6, 13", tableSize: 7,
                        code: `// ì½”ë“œëŠ” ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤.`
                    },
                    chaining: {
                        name: "ì²´ì´ë‹",
                        idea: "ì¶©ëŒì´ ë°œìƒí•˜ë©´, í•´ë‹¹ ì£¼ì†Œì— ë°ì´í„°ë¥¼ ì—°ê²° ë¦¬ìŠ¤íŠ¸(chain) í˜•íƒœë¡œ ê³„ì†í•´ì„œ ì—°ê²°í•˜ì—¬ ì €ì¥í•©ë‹ˆë‹¤.",
                        defaultInput: "8, 1, 9, 6, 13", tableSize: 7,
                        code: `// ì½”ë“œëŠ” ìƒëµë˜ì—ˆìŠµë‹ˆë‹¤.`
                    }
                }
            }
        };
        
        // --- Full script ---
        // --- UI Generation ---
        function generateAlgorithmPage(algoKey) {
            const algo = algorithms[algoKey];
            if (algo.type === 'conceptual') return generateConceptualPage(algoKey);
            if (algo.type === 'conceptual-container') return generateHashingContainerPage(algoKey);

            const isSearch = algo.type === 'search';
            const targetInputHTML = isSearch ? `
                <div class="flex-1">
                    <label for="target-input" class="block text-sm font-medium text-slate-700 mb-1">ì°¾ì„ ê°’</label>
                    <input type="text" id="target-input" class="w-full p-2 border border-slate-300 rounded-md" value="${algo.defaultTarget}">
                </div>` : '';
            const searchWarningHTML = algoKey === 'binarySearch' || algoKey === 'interpolationSearch' ? `<p class="text-sm text-red-500 mt-2">âš ï¸ ì´ íƒìƒ‰ì€ ë°˜ë“œì‹œ ì •ë ¬ëœ ë°ì´í„°ë¥¼ ì…ë ¥í•´ì•¼ í•©ë‹ˆë‹¤.</p>` : '';

            return `
                <div class="space-y-8">
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-3">${algo.name}</h3>
                        <p class="text-lg font-semibold text-indigo-600 mb-2">${algo.idea}</p>
                        <p class="text-slate-600">${algo.analogy}</p>
                    </section>
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-4">ì¸í„°ë™í‹°ë¸Œ ì‹œë®¬ë ˆì´í„°</h3>
                        <div class="flex flex-col md:flex-row gap-4 mb-4">
                            <div class="flex-grow">
                                <label for="data-input" class="block text-sm font-medium text-slate-700 mb-1">ë°ì´í„° ì…ë ¥ (ì‰¼í‘œë¡œ êµ¬ë¶„)</label>
                                <input type="text" id="data-input" class="w-full p-2 border border-slate-300 rounded-md" value="${algo.defaultInput}">
                                ${searchWarningHTML}
                            </div>
                            ${targetInputHTML}
                        </div>
                        <div id="controls" class="flex flex-wrap items-center gap-3 mb-4">
                            <button id="start-btn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">â–¶ ì‹œì‘</button>
                            <button id="pause-btn" class="bg-yellow-500 text-white px-4 py-2 rounded-md hover:bg-yellow-600" disabled>âšâš ì¼ì‹œì •ì§€</button>
                            <button id="step-btn" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600">â¯ í•œ ë‹¨ê³„ì”©</button>
                            <button id="reset-btn" class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600">â†º ì´ˆê¸°í™”</button>
                            <div class="flex items-center gap-2 ml-auto">
                                <label for="speed-slider" class="text-sm">ì†ë„:</label>
                                <input type="range" id="speed-slider" min="100" max="1000" value="500" class="w-32">
                            </div>
                        </div>
                        <div id="visualization-area" class="bg-slate-100 p-4 rounded-md min-h-[250px] flex justify-center items-end gap-1 overflow-x-auto viz-container"></div>
                    </section>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <section class="bg-white p-6 rounded-lg shadow">
                            <h3 class="text-2xl font-bold mb-4">ë‹¨ê³„ë³„ ì„¤ëª… (Log)</h3>
                            <div id="log-area" class="h-64 overflow-y-auto bg-slate-50 rounded p-2 border"></div>
                        </section>
                        <section class="bg-white p-6 rounded-lg shadow">
                            <div class="flex justify-between items-center mb-4">
                                <h3 class="text-2xl font-bold">ì½”ë“œ ë³´ê¸° (C ì–¸ì–´)</h3>
                                <button id="copy-code-btn" class="bg-slate-200 text-sm px-3 py-1 rounded hover:bg-slate-300">ì½”ë“œ ë³µì‚¬</button>
                            </div>
                            <pre class="bg-slate-800 text-white p-4 rounded-md h-64 overflow-auto"><code id="code-snippet"></code></pre>
                        </section>
                    </div>
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-4">ì„±ëŠ¥ ë¶„ì„ (ì‹œê°„ ë³µì¡ë„)</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                            <div class="bg-green-50 p-4 rounded-lg border border-green-200">
                                <h4 class="text-lg font-bold text-green-700">ìµœì„  (Best)</h4>
                                <p class="text-2xl font-mono my-2 text-green-800">${algo.performance.best.notation}</p>
                            </div>
                            <div class="bg-blue-50 p-4 rounded-lg border border-blue-200">
                                <h4 class="text-lg font-bold text-blue-700">í‰ê·  (Average)</h4>
                                <p class="text-2xl font-mono my-2 text-blue-800">${algo.performance.average.notation}</p>
                            </div>
                            <div class="bg-red-50 p-4 rounded-lg border border-red-200">
                                <h4 class="text-lg font-bold text-red-700">ìµœì•… (Worst)</h4>
                                <p class="text-2xl font-mono my-2 text-red-800">${algo.performance.worst.notation}</p>
                            </div>
                        </div>
                    </section>
                </div>`;
        }
        
        function generateConceptualPage(algoKey) {
            const algo = algorithms[algoKey];
            return `
                <div class="space-y-8">
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-3">${algo.name}</h3>
                        <p class="text-lg font-semibold text-indigo-600 mb-2">${algo.idea}</p>
                        <p class="text-slate-600">${algo.analogy}</p>
                    </section>
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-4">í•µì‹¬ ì›ë¦¬</h3>
                        ${algo.visualization}
                    </section>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                        <section class="bg-white p-6 rounded-lg shadow">
                            <h3 class="text-2xl font-bold mb-4">ì½”ë“œ ë³´ê¸° (C ì–¸ì–´)</h3>
                            <pre class="bg-slate-800 text-white p-4 rounded-md h-48 overflow-auto"><code>${algo.code.c}</code></pre>
                        </section>
                        <section class="bg-white p-6 rounded-lg shadow">
                            <h3 class="text-2xl font-bold mb-4">ì„±ëŠ¥ ë¶„ì„</h3>
                            <p class="text-lg text-slate-700">${algo.performanceText}</p>
                        </section>
                    </div>
                </div>
            `;
        }

        function generateHashingContainerPage(algoKey) {
            const algo = algorithms[algoKey];
            let subNavHTML = '<div id="hashing-nav" class="flex flex-wrap justify-center gap-2 mb-6">';
            for (const subKey in algo.subAlgos) {
                subNavHTML += `<button class="tab-item p-2 border rounded" data-subkey="${subKey}">${algo.subAlgos[subKey].name}</button>`;
            }
            subNavHTML += '</div>';

            return `
                <div class="space-y-8">
                    <section class="bg-white p-6 rounded-lg shadow">
                        <h3 class="text-2xl font-bold mb-3">${algo.name}</h3>
                        <p class="text-lg font-semibold text-indigo-600 mb-2">${algo.idea}</p>
                        <p class="text-slate-600">${algo.analogy}</p>
                    </section>
                    ${subNavHTML}
                    <div id="hashing-content"></div>
                </div>
            `;
        }
        
        function generateHashingSimulatorPage(subKey) {
            const subAlgo = algorithms.hashing.subAlgos[subKey];
            return `
                <section class="bg-white p-6 rounded-lg shadow">
                    <h3 class="text-2xl font-bold mb-2">${subAlgo.name}</h3>
                    <div class="text-slate-600 mb-4">${subAlgo.idea}</div>
                    <div class="flex flex-col md:flex-row gap-4 mb-4">
                        <div class="flex-grow">
                            <label for="data-input" class="block text-sm font-medium text-slate-700 mb-1">ì…ë ¥ ë°ì´í„° (í•´ì‹œ í…Œì´ë¸” í¬ê¸°: ${subAlgo.tableSize})</label>
                            <input type="text" id="data-input" class="w-full p-2 border border-slate-300 rounded-md" value="${subAlgo.defaultInput}">
                        </div>
                    </div>
                    <div id="controls" class="flex flex-wrap items-center gap-3 mb-4">
                         <button id="start-btn" class="bg-blue-500 text-white px-4 py-2 rounded-md hover:bg-blue-600">â–¶ ì‹œì‘</button>
                         <button id="pause-btn" class="bg-yellow-500 text-white px-4 py-2 rounded-md hover:bg-yellow-600" disabled>âšâš ì¼ì‹œì •ì§€</button>
                         <button id="step-btn" class="bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600">â¯ í•œ ë‹¨ê³„ì”©</button>
                         <button id="reset-btn" class="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600">â†º ì´ˆê¸°í™”</button>
                    </div>
                    <div id="visualization-area" class="bg-slate-100 p-4 rounded-md min-h-[200px] overflow-x-auto"></div>
                    <div id="collision-summary" class="mt-4 text-center font-semibold text-lg text-indigo-700"></div>
                </section>
                <section class="bg-white p-6 rounded-lg shadow mt-8">
                    <h3 class="text-2xl font-bold mb-4">ë‹¨ê³„ë³„ ì„¤ëª… (Log)</h3>
                    <div id="log-area" class="h-64 overflow-y-auto bg-slate-50 rounded p-2 border"></div>
                </section>
            `;
        }

        // --- Page Navigation & Setup ---
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => page.classList.add('hidden'));
            document.getElementById(`${pageId}-page`).classList.remove('hidden');
            if (pageId === 'sorting') {
                if (!document.querySelector('#sorting-nav .active')) {
                    document.querySelector('#sorting-nav .nav-item').click();
                }
            } else if (pageId === 'searching') {
                if (!document.querySelector('#searching-nav .active')) {
                    document.querySelector('#searching-nav .nav-item').click();
                }
            }
        }

        function selectAlgorithm(algoKey) {
            currentAlgorithm = algoKey;
            const algo = algorithms[algoKey];
            const containerId = (algo.type === 'sort') ? 'algorithm-content' : 'search-algorithm-content';
            document.getElementById(containerId).innerHTML = generateAlgorithmPage(algoKey);
            
            if (algo.type === 'conceptual-container') {
                document.querySelectorAll('#hashing-nav .tab-item').forEach(tab => {
                    tab.addEventListener('click', (e) => {
                        const subKey = e.target.dataset.subkey;
                        document.getElementById('hashing-content').innerHTML = generateHashingSimulatorPage(subKey);
                        currentAlgorithm = subKey; // Set current algorithm to the sub-key for simulation
                        setupEventListeners();
                        resetVisualizer();
                        document.querySelectorAll('#hashing-nav .tab-item').forEach(t => t.classList.remove('active'));
                        e.target.classList.add('active');
                    });
                });
                document.querySelector('#hashing-nav .tab-item').click();
            } else if (algo.type !== 'conceptual') {
                setupEventListeners();
                resetVisualizer();
            }
            
            const navContainerId = (algo.type === 'sort') ? 'sorting-nav' : 'searching-nav';
            document.querySelectorAll(`#${navContainerId} .nav-item`).forEach(item => {
                item.classList.toggle('active', item.dataset.algo === algoKey);
            });
        }

        function setupEventListeners() {
            const startBtn = document.getElementById('start-btn');
            if (!startBtn) return; // Guard clause if controls don't exist
            
            startBtn.addEventListener('click', startAnimation);
            document.getElementById('pause-btn').addEventListener('click', pauseAnimation);
            document.getElementById('step-btn').addEventListener('click', stepAnimation);
            document.getElementById('reset-btn').addEventListener('click', resetVisualizer);
            document.getElementById('speed-slider').addEventListener('input', (e) => { animationState.speed = 1100 - e.target.value; });
            document.getElementById('data-input').addEventListener('change', resetVisualizer);
            const targetInput = document.getElementById('target-input');
            if (targetInput) targetInput.addEventListener('change', resetVisualizer);
            
            const codeSnippet = document.getElementById('code-snippet');
            if (codeSnippet) {
                const algoData = algorithms[currentAlgorithm] || (algorithms.hashing && algorithms.hashing.subAlgos[currentAlgorithm]);
                if (algoData && algoData.code) {
                    codeSnippet.textContent = typeof algoData.code === 'string' ? algoData.code : algoData.code.c;
                }
            }
            
            const copyBtn = document.getElementById('copy-code-btn');
            if (copyBtn) copyBtn.addEventListener('click', copyCodeToClipboard);
        }

        function copyCodeToClipboard() {
            const code = document.getElementById('code-snippet').textContent;
            const btn = document.getElementById('copy-code-btn');
            navigator.clipboard.writeText(code).then(() => {
                btn.textContent = 'ë³µì‚¬ ì™„ë£Œ!';
                setTimeout(() => { btn.textContent = 'ì½”ë“œ ë³µì‚¬'; }, 2000);
            });
        }

        // --- Visualization & Animation ---
        function parseInput(inputId) {
            const inputEl = document.getElementById(inputId);
            if (!inputEl) return [];
            return inputEl.value.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));
        }

        function renderArray(state) {
            const vizArea = document.getElementById('visualization-area');
            if (!vizArea) return;
            vizArea.innerHTML = '';
            
            const specialRenderers = {
                shellSort: renderShellSort,
                mergeSort: renderMergeSort,
                quickSort: renderQuickSort,
                radixSort: renderRadixSort,
                linearProbing: renderHashTable,
                quadraticProbing: renderHashTable,
                doubleHashing: renderHashTable,
                chaining: renderHashTable
            };

            if (specialRenderers[currentAlgorithm]) {
                specialRenderers[currentAlgorithm](state);
                return;
            }

            const array = state.array;
            const maxValue = Math.max(...array, 1);
            
            array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar flex-grow text-center font-bold text-white rounded-t-md';
                const height = (value / maxValue) * 90 + 10;
                bar.style.height = `${height}%`;
                bar.textContent = value;
                
                let bgColors = ['bg-slate-400'];
                if (state.sorted && state.sorted.includes(index)) bgColors = ['bg-green-500'];
                if (state.comparing && state.comparing.includes(index)) bgColors = ['bg-yellow-500'];
                if (state.special && state.special.includes(index)) bgColors = ['bg-orange-500'];
                if (state.found === index) {
                    bgColors = ['bg-green-500', 'animate-pulse'];
                }
                if (state.pivot === index) bgColors = ['bg-purple-500'];
                if (state.range && (index < state.range[0] || index > state.range[1])) {
                    bgColors = ['bg-slate-200'];
                    bar.classList.add('opacity-50');
                }
                bar.classList.add(...bgColors);
                vizArea.appendChild(bar);
            });
        }
        
        // --- Enhanced Visualizers ---
        function renderShellSort(state) {
            const vizArea = document.getElementById('visualization-area');
            vizArea.innerHTML = '';
            const array = state.array;
            const maxValue = Math.max(...array, 1);
            const container = document.createElement('div');
            container.className = 'flex justify-center items-end gap-1 w-full';

            array.forEach((value, index) => {
                const barWrapper = document.createElement('div');
                barWrapper.className = 'flex-grow shell-gap-group';
                
                const bar = document.createElement('div');
                bar.className = 'bar text-center font-bold text-white rounded-t-md mx-auto';
                const height = (value / maxValue) * 90 + 10;
                bar.style.height = `${height}%`;
                bar.style.width = '80%';
                bar.textContent = value;
                
                let bgColor = 'bg-slate-400';
                if (state.comparing && state.comparing.includes(index)) {
                     bgColor = 'bg-yellow-500';
                     barWrapper.classList.add('active');
                }
                if (state.special && state.special.includes(index)) {
                    bgColor = 'bg-orange-500';
                    barWrapper.classList.add('active');
                }
                if (state.current_gap_group && state.current_gap_group.includes(index)) {
                    barWrapper.classList.add('active');
                }
                
                bar.classList.add(bgColor);
                barWrapper.appendChild(bar);
                container.appendChild(barWrapper);
            });
            vizArea.appendChild(container);
        }
        
        function renderMergeSort(state) {
            const vizArea = document.getElementById('visualization-area');
            vizArea.innerHTML = '';
            if (!state || !state.array) return;
            const maxValue = Math.max(...state.array, 1);

            function createSubArray(arr, indices, isComparing) {
                const subArrayDiv = document.createElement('div');
                subArrayDiv.className = 'sub-array';
                arr.forEach((val, i) => {
                    const bar = document.createElement('div');
                    bar.className = 'sub-bar';
                    bar.style.height = `${(val / maxValue) * 50 + 10}px`;
                    if (isComparing && indices && indices.includes(i)) {
                        bar.classList.add('bg-yellow-500');
                    }
                    bar.textContent = val;
                    subArrayDiv.appendChild(bar);
                });
                return subArrayDiv;
            }
            
            if (!state.levels) {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'merge-level';
                levelDiv.appendChild(createSubArray(state.array));
                vizArea.appendChild(levelDiv);
                return;
            }

            state.levels.forEach(level => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'merge-level';
                level.forEach(group => {
                    levelDiv.appendChild(createSubArray(group.arr, group.indices, group.isComparing));
                });
                vizArea.appendChild(levelDiv);
            });
        }

        function renderQuickSort(state) {
            const vizArea = document.getElementById('visualization-area');
            vizArea.innerHTML = '';
            const array = state.array;
            const maxValue = Math.max(...array, 1);
            const partitionDiv = document.createElement('div');
            partitionDiv.className = 'quick-partition flex justify-center items-end gap-1 w-full';
            if (state.range) {
                partitionDiv.style.borderLeft = `${state.range[0] * 2.5}rem solid transparent`;
                partitionDiv.style.borderRight = `${(array.length - 1 - state.range[1]) * 2.5}rem solid transparent`;
            }

            array.forEach((value, index) => {
                const bar = document.createElement('div');
                bar.className = 'bar flex-grow text-center font-bold text-white rounded-t-md';
                const height = (value / maxValue) * 90 + 10;
                bar.style.height = `${height}%`;
                bar.textContent = value;
                
                let bgColor = 'bg-slate-400';
                if (state.sorted && state.sorted.includes(index)) bgColor = 'bg-green-500';
                else if (state.pivot === index) bgColor = 'bg-purple-500';
                else if (state.comparing && state.comparing.includes(index)) bgColor = 'bg-yellow-500';
                else if (state.special && state.special.includes(index)) bgColor = 'bg-orange-500';

                if (state.range && (index < state.range[0] || index > state.range[1])) {
                    bar.classList.add('opacity-30');
                }
                
                bar.classList.add(bgColor);
                partitionDiv.appendChild(bar);
            });
            vizArea.appendChild(partitionDiv);
        }

        function renderRadixSort(state) {
            const vizArea = document.getElementById('visualization-area');
            vizArea.innerHTML = '';
            const container = document.createElement('div');
            container.className = 'flex flex-col items-center gap-4';

            const arrayDiv = document.createElement('div');
            arrayDiv.className = 'flex justify-center items-end gap-1 w-full h-24';
            state.array.forEach((val, idx) => {
                const bar = document.createElement('div');
                bar.className = 'bar flex-grow text-center font-bold text-white rounded-t-md bg-blue-400';
                bar.style.height = '50%';
                if (state.special && state.special.includes(idx)) {
                    bar.classList.add('bg-orange-500');
                }
                bar.textContent = val;
                arrayDiv.appendChild(bar);
            });
            container.appendChild(arrayDiv);

            const bucketContainer = document.createElement('div');
            bucketContainer.className = 'flex justify-around w-full items-end';
            for (let i = 0; i < 10; i++) {
                const bucketDiv = document.createElement('div');
                bucketDiv.className = 'flex flex-col-reverse gap-1 p-1 border rounded min-h-[100px] min-w-[50px] bg-slate-200';
                const title = document.createElement('div');
                title.className = 'text-xs font-bold text-center';
                title.textContent = `[${i}]`;
                
                if (state.buckets && state.buckets[i]) {
                    state.buckets[i].forEach(val => {
                        const item = document.createElement('div');
                        item.className = 'bg-blue-500 text-white p-1 rounded text-sm text-center';
                        item.textContent = val;
                        bucketDiv.appendChild(item);
                    });
                }
                bucketDiv.appendChild(title);
                bucketContainer.appendChild(bucketDiv);
            }
            container.appendChild(bucketContainer);
            vizArea.appendChild(container);
        }
        
        function renderHashTable(state) {
            const vizArea = document.getElementById('visualization-area');
            vizArea.innerHTML = '';
            const table = document.createElement('div');
            table.className = 'hash-table';
            
            state.table.forEach((slot, index) => {
                const slotDiv = document.createElement('div');
                slotDiv.className = 'hash-slot';
                if (state.comparing === index) slotDiv.classList.add('comparing');
                if (state.collided === index) slotDiv.classList.add('collided');
                
                const indexSpan = document.createElement('span');
                indexSpan.className = 'slot-index';
                indexSpan.textContent = index;
                slotDiv.appendChild(indexSpan);

                if (currentAlgorithm === 'chaining') {
                    if (slot && slot.length > 0) {
                        slot.forEach(val => {
                            const item = document.createElement('div');
                            item.className = 'chain-item';
                            item.textContent = val;
                            slotDiv.appendChild(item);
                        });
                    }
                } else {
                    if (slot !== null) {
                        slotDiv.textContent = slot;
                        slotDiv.appendChild(indexSpan); // re-append index
                        slotDiv.classList.add('occupied');
                    }
                }
                table.appendChild(slotDiv);
            });
            vizArea.appendChild(table);
        }

        function updateLog(log, currentStep) {
            const logArea = document.getElementById('log-area');
            if(!logArea) return;
            logArea.innerHTML = '';
            log.forEach((entry, index) => {
                const p = document.createElement('p');
                p.textContent = entry;
                p.className = 'log-item p-1 rounded text-sm';
                if (index === currentStep) {
                    p.classList.add('active', 'font-bold');
                    p.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                logArea.appendChild(p);
            });
        }
        
        function resetVisualizer() {
            resetAnimation();
            const initialArray = parseInput('data-input');
            if (currentAlgorithm && (currentAlgorithm.includes('Probing') || currentAlgorithm === 'chaining')) {
                const size = algorithms.hashing.subAlgos[currentAlgorithm].tableSize;
                renderHashTable({ table: (currentAlgorithm === 'chaining') ? Array.from({length: size}, () => []) : Array(size).fill(null) });
            } else if (currentAlgorithm === 'mergeSort') {
                renderArray({ array: initialArray, levels: [[{ arr: initialArray, offset: 0 }]] });
            }
             else {
                 renderArray({ array: initialArray });
            }
            if (document.getElementById('log-area')) {
                document.getElementById('log-area').innerHTML = '';
            }
            const summaryDiv = document.getElementById('collision-summary');
            if (summaryDiv) summaryDiv.textContent = '';
        }
        
        function updateControls(isPlaying, isFinished) {
            const startBtn = document.getElementById('start-btn');
            if (startBtn) {
                startBtn.disabled = isPlaying || isFinished;
                document.getElementById('pause-btn').disabled = !isPlaying || isFinished;
                document.getElementById('step-btn').disabled = isPlaying || isFinished;
                document.getElementById('data-input').disabled = isPlaying;
                const targetInput = document.getElementById('target-input');
                if (targetInput) targetInput.disabled = isPlaying;
            }
        }

        function startAnimation() {
            if (animationState.isPlaying) return;
            if (!animationState.isPaused) {
                const algoFunction = getAlgorithmFunction(currentAlgorithm);
                if (!algoFunction) return;
                const array = parseInput('data-input');
                let target = null;
                const mainAlgo = algorithms[currentAlgorithm];
                if (mainAlgo && mainAlgo.type === 'search') {
                    target = parseInt(document.getElementById('target-input').value);
                }
                animationState.steps = algoFunction(array, target);
                animationState.currentStep = 0;
            }
            animationState.isPlaying = true;
            animationState.isPaused = false;
            updateControls(true, false);
            animateStep();
        }

        function pauseAnimation() {
            animationState.isPlaying = false;
            animationState.isPaused = true;
            clearTimeout(animationState.timeoutId);
            updateControls(false, false);
        }

        function stepAnimation() {
            if (animationState.currentStep === 0 && !animationState.isPaused) {
                 const algoFunction = getAlgorithmFunction(currentAlgorithm);
                 if (!algoFunction) return;
                 const array = parseInput('data-input');
                 let target = null;
                 const mainAlgo = algorithms[currentAlgorithm];
                 if (mainAlgo && mainAlgo.type === 'search') {
                    target = parseInt(document.getElementById('target-input').value);
                 }
                 animationState.steps = algoFunction(array, target);
            }
            if (animationState.steps && animationState.currentStep < animationState.steps.length) {
                const step = animationState.steps[animationState.currentStep];
                renderArray(step.state);
                updateLog(animationState.steps.map(s => s.log), animationState.currentStep);
                animationState.currentStep++;
            }
            if (!animationState.steps || animationState.currentStep >= animationState.steps.length) {
                updateControls(false, true);
            }
        }
        
        function animateStep() {
            if (!animationState.isPlaying) return;
            if (!animationState.steps || animationState.currentStep >= animationState.steps.length) {
                resetAnimation();
                updateControls(false, true);
                const finalStep = animationState.steps ? animationState.steps[animationState.steps.length - 1] : null;
                if (finalStep) {
                    let finalState = { ...finalStep.state };
                    if (finalStep.state.array) {
                       finalState.sorted = finalStep.state.array.map((_, i) => i);
                    }
                    if (finalStep.state.found !== undefined) finalState.found = finalStep.state.found;
                    if (finalStep.summary) {
                        const summaryDiv = document.getElementById('collision-summary');
                        if (summaryDiv) summaryDiv.textContent = finalStep.summary;
                    }
                    renderArray(finalState);
                }
                return;
            }
            const step = animationState.steps[animationState.currentStep];
            renderArray(step.state);
            updateLog(animationState.steps.map(s => s.log), animationState.currentStep);
            animationState.currentStep++;
            animationState.timeoutId = setTimeout(animateStep, animationState.speed);
        }
        
        function resetAnimation() {
            clearTimeout(animationState.timeoutId);
            animationState = { ...animationState, isPlaying: false, isPaused: false, steps: [], currentStep: 0, timeoutId: null };
            updateControls(false, false);
        }

        // --- Algorithm Logic (Step Generation) ---
        const deepCopy = (obj) => JSON.parse(JSON.stringify(obj));

        function getAlgorithmFunction(algoKey) {
            const functions = {
                bubbleSort: generateBubbleSortSteps,
                selectionSort: generateSelectionSortSteps,
                insertionSort: generateInsertionSortSteps,
                shellSort: generateShellSortSteps,
                mergeSort: generateMergeSortSteps,
                quickSort: generateQuickSortSteps,
                radixSort: generateRadixSortSteps,
                sequentialSearch: generateSequentialSearchSteps,
                binarySearch: generateBinarySearchSteps,
                interpolationSearch: generateInterpolationSearchSteps,
                linearProbing: generateHashingSteps,
                quadraticProbing: generateHashingSteps,
                doubleHashing: generateHashingSteps,
                chaining: generateHashingSteps,
            };
            return functions[algoKey];
        }
        
        function generateBubbleSortSteps(array) {
            const steps = []; let arr = [...array]; let n = arr.length; let sortedIndices = [];
            steps.push({ state: { array: [...arr], comparing: [], sorted: [] }, log: "ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    steps.push({ state: { array: [...arr], comparing: [j, j + 1], sorted: [...sortedIndices] }, log: `${i + 1}íšŒì „: ${arr[j]}ì™€(ê³¼) ${arr[j+1]}ì„(ë¥¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        steps.push({ state: { array: [...arr], comparing: [j, j + 1], sorted: [...sortedIndices] }, log: `${arr[j+1]}ì´(ê°€) ë” í¬ë¯€ë¡œ ìœ„ì¹˜ë¥¼ êµí™˜í•©ë‹ˆë‹¤.` });
                    }
                }
                sortedIndices.push(n - 1 - i);
                steps.push({ state: { array: [...arr], comparing: [], sorted: [...sortedIndices] }, log: `${i + 1}íšŒì „ ì¢…ë£Œ. ê°€ì¥ í° ê°’ ${arr[n-1-i]}ì´(ê°€) ì œìë¦¬ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.` });
            }
            sortedIndices.push(0);
            steps.push({ state: { array: [...arr], comparing: [], sorted: [...sortedIndices] }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }

        function generateSelectionSortSteps(array) {
            const steps = []; let arr = [...array]; let n = arr.length; let sortedIndices = [];
            steps.push({ state: { array: [...arr], sorted: [] }, log: "ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                steps.push({ state: { array: [...arr], special: [minIdx], sorted: [...sortedIndices] }, log: `${i + 1}íšŒì „: ${i}ë²ˆ ìœ„ì¹˜ì— ë“¤ì–´ê°ˆ ê°€ì¥ ì‘ì€ ê°’ì„ ì°¾ìŠµë‹ˆë‹¤.` });
                for (let j = i + 1; j < n; j++) {
                    steps.push({ state: { array: [...arr], comparing: [j], special: [minIdx], sorted: [...sortedIndices] }, log: `í˜„ì¬ ìµœì†Œê°’ ${arr[minIdx]}ì™€(ê³¼) ${arr[j]}ì„(ë¥¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                        steps.push({ state: { array: [...arr], comparing: [j], special: [minIdx], sorted: [...sortedIndices] }, log: `${arr[j]}ì´(ê°€) ë” ì‘ìœ¼ë¯€ë¡œ ìµœì†Œê°’ì„ ê°±ì‹ í•©ë‹ˆë‹¤.` });
                    }
                }
                steps.push({ state: { array: [...arr], comparing: [i, minIdx], special: [], sorted: [...sortedIndices] }, log: `ìµœì†Œê°’ ${arr[minIdx]}ì„(ë¥¼) ${i}ë²ˆ ìœ„ì¹˜ì˜ ${arr[i]}ì™€(ê³¼) êµí™˜í•©ë‹ˆë‹¤.` });
                [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                sortedIndices.push(i);
                steps.push({ state: { array: [...arr], special: [], sorted: [...sortedIndices] }, log: `${i}ë²ˆ ìœ„ì¹˜ê°€ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤.` });
            }
            steps.push({ state: { array: [...arr], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }
        
        function generateInsertionSortSteps(array) {
            const steps = []; let arr = [...array]; let n = arr.length; let sortedIndices = [0];
            steps.push({ state: { array: [...arr], sorted: [0] }, log: "ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì²« ë²ˆì§¸ ìš”ì†ŒëŠ” ì •ë ¬ëœ ê²ƒìœ¼ë¡œ ê°„ì£¼í•©ë‹ˆë‹¤." });
            for (let i = 1; i < n; i++) {
                let key = arr[i]; let j = i - 1;
                steps.push({ state: { array: [...arr], special: [i], sorted: [...sortedIndices] }, log: `${key}ì„(ë¥¼) ì •ë ¬ëœ ë¶€ë¶„ì— ì‚½ì…í•©ë‹ˆë‹¤.` });
                while (j >= 0 && arr[j] > key) {
                    steps.push({ state: { array: [...arr], comparing: [j], special: [i], sorted: [...sortedIndices] }, log: `${key}ì´(ê°€) ${arr[j]}ë³´ë‹¤ ì‘ìœ¼ë¯€ë¡œ ${arr[j]}ì„(ë¥¼) ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.` });
                    arr[j + 1] = arr[j]; j--;
                    steps.push({ state: { array: [...arr], comparing: [], special: [i], sorted: [...sortedIndices] }, log: `ì´ë™ ì™„ë£Œ.` });
                }
                arr[j + 1] = key; sortedIndices.push(i); sortedIndices.sort((a,b)=>a-b);
                steps.push({ state: { array: [...arr], special: [], sorted: [...sortedIndices] }, log: `ë¹ˆ ìë¦¬ì— ${key}ì„(ë¥¼) ì‚½ì…í•©ë‹ˆë‹¤.` });
            }
            steps.push({ state: { array: [...arr], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }
        
        function generateShellSortSteps(array) {
            const steps = []; let arr = [...array]; let n = arr.length;
            steps.push({ state: { array: [...arr] }, log: "ì‰˜ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });
            for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {
                steps.push({ state: { array: [...arr] }, log: `ê°„ê²©(Gap) = ${gap}ìœ¼ë¡œ ë¶€ë¶„ ë¦¬ìŠ¤íŠ¸ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤.` });
                for (let i = gap; i < n; i++) {
                    const current_gap_group = [];
                    for(let k=i%gap; k<n; k+=gap) current_gap_group.push(k);
                    let temp = arr[i]; let j = i;
                    steps.push({ state: { array: [...arr], special: [j], current_gap_group }, log: `${arr[j]}ì„(ë¥¼) ê°„ê²©(${gap})ì— ë§ì¶° ì‚½ì…í•  ìœ„ì¹˜ë¥¼ ì°¾ìŠµë‹ˆë‹¤.` });
                    while (j >= gap && arr[j - gap] > temp) {
                        steps.push({ state: { array: [...arr], comparing: [j, j - gap], special: [j], current_gap_group }, log: `${arr[j-gap]}ì´(ê°€) ${temp}ë³´ë‹¤ í¬ë¯€ë¡œ ì´ë™í•©ë‹ˆë‹¤.` });
                        arr[j] = arr[j - gap]; j -= gap;
                    }
                    arr[j] = temp;
                    steps.push({ state: { array: [...arr], special: [j], current_gap_group }, log: `${temp}ì„(ë¥¼) ${j}ë²ˆ ìœ„ì¹˜ì— ì‚½ì…í–ˆìŠµë‹ˆë‹¤.` });
                }
            }
            steps.push({ state: { array: [...arr], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }

        function generateMergeSortSteps(array) {
            const steps = []; let arr = [...array];
            let levels = [[{arr: [...arr], offset: 0}]];
            
            steps.push({ state: { array: [...arr], levels: deepCopy(levels) }, log: "í•©ë³‘ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });

            // ë¶„í•  ê³¼ì •
            let currentLevel = levels[0];
            while(currentLevel.some(group => group.arr.length > 1)) {
                const nextLevel = [];
                currentLevel.forEach(group => {
                    if (group.arr.length > 1) {
                        const middle = Math.ceil(group.arr.length / 2);
                        nextLevel.push({ arr: group.arr.slice(0, middle), offset: group.offset });
                        nextLevel.push({ arr: group.arr.slice(middle), offset: group.offset + middle });
                    } else {
                        nextLevel.push(group);
                    }
                });
                levels.push(nextLevel);
                steps.push({ state: { array: [...arr], levels: deepCopy(levels) }, log: `ë°°ì—´ì„ ë” ì‘ì€ ë‹¨ìœ„ë¡œ ë¶„í• í•©ë‹ˆë‹¤.` });
                currentLevel = nextLevel;
            }

            // í•©ë³‘ ê³¼ì •
            for (let i = levels.length - 2; i >= 0; i--) {
                for (let j = 0; j < levels[i+1].length; j += 2) {
                    const leftGroup = levels[i+1][j];
                    const rightGroup = levels[i+1][j+1];
                    
                    const left = leftGroup.arr;
                    const right = rightGroup ? rightGroup.arr : [];
                    const offset = leftGroup.offset;

                    let result = [], l = 0, r = 0;
                    
                    levels[i+1][j].isComparing = true;
                    if(rightGroup) levels[i+1][j+1].isComparing = true;
                    steps.push({ state: { array: [...arr], levels: deepCopy(levels) }, log: `[${left}]ì™€(ê³¼) [${right}]ë¥¼ í•©ë³‘í•©ë‹ˆë‹¤.` });
                    
                    while (l < left.length && r < right.length) {
                        if (left[l] <= right[r]) {
                            result.push(left[l++]);
                        } else {
                            result.push(right[r++]);
                        }
                    }
                    result = result.concat(left.slice(l)).concat(right.slice(r));
                    
                    for(let k=0; k<result.length; k++) {
                        arr[offset + k] = result[k];
                    }
                    
                    levels[i].find(g => g.offset === offset).arr = result;
                    delete levels[i+1][j].isComparing;
                    if(rightGroup) delete levels[i+1][j+1].isComparing;
                    steps.push({ state: { array: [...arr], levels: deepCopy(levels) }, log: `í•©ë³‘ ê²°ê³¼: [${result}]` });
                }
            }
            
            steps.push({ state: { array: [...arr], levels: [], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }

        function generateQuickSortSteps(array) {
            const steps = []; let arr = [...array];
            function quickSortRecursive(low, high) {
                if (low < high) {
                    const pi = partition(low, high);
                    quickSortRecursive(low, pi - 1);
                    quickSortRecursive(pi + 1, high);
                }
            }
            function partition(low, high) {
                const pivot = arr[low];
                let i = high + 1;
                steps.push({ state: { array: [...arr], pivot: low, range: [low, high] }, log: `ë²”ìœ„ [${low}~${high}]ì˜ í”¼ë²—ìœ¼ë¡œ ${pivot}ì„(ë¥¼) ì„ íƒí•©ë‹ˆë‹¤.` });

                for (let j = high; j > low; j--) {
                    steps.push({ state: { array: [...arr], comparing: [j], pivot: low, special: i <= high ? [i-1] : [], range: [low, high] }, log: `${arr[j]}ì™€ í”¼ë²— ${pivot}ì„(ë¥¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                    if (arr[j] > pivot) {
                        i--;
                        steps.push({ state: { array: [...arr], comparing: [i, j], pivot: low, range: [low, high] }, log: `${arr[j]}ì´(ê°€) í”¼ë²—ë³´ë‹¤ í¬ë¯€ë¡œ ${arr[i]}ì™€(ê³¼) êµí™˜í•©ë‹ˆë‹¤.` });
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        steps.push({ state: { array: [...arr], comparing: [], pivot: low, range: [low, high] }, log: `êµí™˜ ì™„ë£Œ.` });
                    }
                }
                steps.push({ state: { array: [...arr], comparing: [i - 1, low], pivot: low, range: [low, high] }, log: `í”¼ë²— ${arr[low]}ì„(ë¥¼) ${arr[i-1]}ì™€(ê³¼) êµí™˜í•˜ì—¬ ì œìë¦¬ë¥¼ ì°¾ìŠµë‹ˆë‹¤.` });
                [arr[i - 1], arr[low]] = [arr[low], arr[i - 1]];
                steps.push({ state: { array: [...arr], sorted: [i-1], range: [low, high] }, log: `í”¼ë²— ${pivot}ì˜ ìœ„ì¹˜ê°€ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤.` });
                return i - 1;
            }
            steps.push({ state: { array: [...arr] }, log: "í€µ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });
            quickSortRecursive(0, arr.length - 1);
            steps.push({ state: { array: [...arr], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }

        function generateRadixSortSteps(array) {
            const steps = []; let arr = [...array]; const maxNum = Math.max(...arr, 0); let exp = 1;
            steps.push({ state: { array: [...arr] }, log: "ê¸°ìˆ˜ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤." });
            while (Math.floor(maxNum / exp) > 0) {
                let buckets = Array.from({ length: 10 }, () => []);
                steps.push({ state: { array: [...arr], buckets: deepCopy(buckets) }, log: `${exp}ì˜ ìë¦¿ìˆ˜ì— ëŒ€í•´ ì •ë ¬ì„ ì‹œì‘í•©ë‹ˆë‹¤.` });
                for (let i = 0; i < arr.length; i++) {
                    const digit = Math.floor(arr[i] / exp) % 10;
                    buckets[digit].push(arr[i]);
                    steps.push({ state: { array: [...arr], buckets: deepCopy(buckets), special: [i] }, log: `${arr[i]}ì„(ë¥¼) ${digit}ë²ˆ ë²„í‚·ì— ë„£ìŠµë‹ˆë‹¤.` });
                }
                let arrIndex = 0;
                steps.push({ state: { array: [...arr], buckets: deepCopy(buckets) }, log: `ë²„í‚·ì—ì„œ ìˆœì„œëŒ€ë¡œ ë°ì´í„°ë¥¼ ë‹¤ì‹œ ê°€ì ¸ì˜µë‹ˆë‹¤.` });
                for (let i = 0; i < 10; i++) {
                    while (buckets[i].length > 0) {
                        arr[arrIndex] = buckets[i].shift();
                        steps.push({ state: { array: [...arr], buckets: deepCopy(buckets) }, log: `${arr[arrIndex]}ì„(ë¥¼) ë°°ì—´ì˜ ${arrIndex}ë²ˆ ìœ„ì¹˜ë¡œ ì´ë™í•©ë‹ˆë‹¤.` });
                        arrIndex++;
                    }
                }
                exp *= 10;
            }
            steps.push({ state: { array: [...arr], sorted: arr.map((_, i) => i) }, log: "ì •ë ¬ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤." });
            return steps;
        }

        function generateSequentialSearchSteps(array, target) {
            const steps = []; let arr = [...array];
            steps.push({ state: { array: [...arr] }, log: `íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì°¾ì„ ê°’: ${target}` });
            for (let i = 0; i < arr.length; i++) {
                steps.push({ state: { array: [...arr], comparing: [i] }, log: `${i}ë²ˆ ì¸ë±ìŠ¤ì˜ ${arr[i]}ì™€(ê³¼) ${target}ì„(ë¥¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                if (arr[i] === target) {
                    steps.push({ state: { array: [...arr], found: i }, log: `ê°’ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤! íƒìƒ‰ ì„±ê³µ.` });
                    return steps;
                }
            }
            steps.push({ state: { array: [...arr] }, log: `ëê¹Œì§€ ê°’ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íƒìƒ‰ ì‹¤íŒ¨.` });
            return steps;
        }

        function generateBinarySearchSteps(array, target) {
            const steps = []; let arr = [...array]; let low = 0; let high = arr.length - 1;
            steps.push({ state: { array: [...arr], range: [low, high] }, log: `íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì°¾ì„ ê°’: ${target}` });
            while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                steps.push({ state: { array: [...arr], comparing: [mid], range: [low, high] }, log: `ë²”ìœ„(${low}~${high})ì˜ ì¤‘ê°„ê°’ ${arr[mid]}ì™€(ê³¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                if (arr[mid] === target) {
                    steps.push({ state: { array: [...arr], found: mid, range: [low, high] }, log: `ê°’ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤! íƒìƒ‰ ì„±ê³µ.` });
                    return steps;
                } else if (arr[mid] < target) {
                    low = mid + 1;
                    steps.push({ state: { array: [...arr], range: [low, high] }, log: `${target}ì´(ê°€) ë” í¬ë¯€ë¡œ ì™¼ìª½ ì ˆë°˜ì„ ë²„ë¦½ë‹ˆë‹¤.` });
                } else {
                    high = mid - 1;
                    steps.push({ state: { array: [...arr], range: [low, high] }, log: `${target}ì´(ê°€) ë” ì‘ìœ¼ë¯€ë¡œ ì˜¤ë¥¸ìª½ ì ˆë°˜ì„ ë²„ë¦½ë‹ˆë‹¤.` });
                }
            }
            steps.push({ state: { array: [...arr] }, log: `ëê¹Œì§€ ê°’ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íƒìƒ‰ ì‹¤íŒ¨.` });
            return steps;
        }

        function generateInterpolationSearchSteps(array, target) {
            const steps = []; let arr = [...array]; let low = 0; let high = arr.length - 1;
            steps.push({ state: { array: [...arr], range: [low, high] }, log: `ë³´ê°„ íƒìƒ‰ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì°¾ì„ ê°’: ${target}` });
            while (low <= high && target >= arr[low] && target <= arr[high]) {
                if (low === high) {
                    if (arr[low] === target) steps.push({ state: { array: [...arr], found: low }, log: "ê°’ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤! íƒìƒ‰ ì„±ê³µ." });
                    else steps.push({ state: { array: [...arr] }, log: "ê°’ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. íƒìƒ‰ ì‹¤íŒ¨." });
                    return steps;
                }
                let pos = low + Math.floor(((high - low) / (arr[high] - arr[low])) * (target - arr[low]));
                if (pos < low || pos > high) { // ì˜ˆì¸¡ ìœ„ì¹˜ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš° ë°©ì§€
                    steps.push({ state: { array: [...arr], range: [low, high] }, log: `ì˜ˆì¸¡ ìœ„ì¹˜(${pos})ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ ìˆœì°¨ íƒìƒ‰ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.` });
                    break; 
                }
                steps.push({ state: { array: [...arr], comparing: [pos], range: [low, high] }, log: `ë²”ìœ„(${low}~${high})ì—ì„œ ìœ„ì¹˜ë¥¼ ì˜ˆì¸¡(${pos})í•˜ì—¬ ${arr[pos]}ì™€(ê³¼) ë¹„êµí•©ë‹ˆë‹¤.` });
                if (arr[pos] === target) {
                    steps.push({ state: { array: [...arr], found: pos, range: [low, high] }, log: "ê°’ì„ ì°¾ì•˜ìŠµë‹ˆë‹¤! íƒìƒ‰ ì„±ê³µ." });
                    return steps;
                }
                if (arr[pos] < target) {
                    low = pos + 1;
                    steps.push({ state: { array: [...arr], range: [low, high] }, log: `${target}ì´(ê°€) ë” í¬ë¯€ë¡œ íƒìƒ‰ ë²”ìœ„ë¥¼ [${low}, ${high}]ë¡œ ì¢í™ë‹ˆë‹¤.` });
                } else {
                    high = pos - 1;
                    steps.push({ state: { array: [...arr], range: [low, high] }, log: `${target}ì´(ê°€) ë” ì‘ìœ¼ë¯€ë¡œ íƒìƒ‰ ë²”ìœ„ë¥¼ [${low}, ${high}]ë¡œ ì¢í™ë‹ˆë‹¤.` });
                }
            }
            steps.push({ state: { array: [...arr] }, log: "íƒìƒ‰ ë²”ìœ„ ë‚´ì— ê°’ì´ ì—†ìŠµë‹ˆë‹¤. íƒìƒ‰ ì‹¤íŒ¨." });
            return steps;
        }
        
        function generateHashingSteps(array) {
            const steps = [];
            const subAlgo = algorithms.hashing.subAlgos[currentAlgorithm];
            const size = subAlgo.tableSize;
            let table = (currentAlgorithm === 'chaining') ? Array.from({length: size}, () => []) : Array(size).fill(null);
            let collisionCount = 0;
            let collisionDetails = {};
            
            steps.push({ state: { table: deepCopy(table) }, log: `${subAlgo.name}ì„(ë¥¼) ì‹œì‘í•©ë‹ˆë‹¤.`});

            for (const key of array) {
                let hash = key % size;
                steps.push({ state: { table: deepCopy(table), comparing: hash }, log: `ë°ì´í„° ${key} ì‚½ì… ì‹œë„. ì´ˆê¸° í•´ì‹œ ê°’: ${hash}` });

                if (currentAlgorithm === 'chaining') {
                    if (table[hash].length > 0) {
                        collisionCount++;
                        collisionDetails[hash] = (collisionDetails[hash] || 0) + 1;
                        steps.push({ state: { table: deepCopy(table), collided: hash }, log: `ì¶©ëŒ ë°œìƒ! ${hash}ë²ˆ ì¸ë±ìŠ¤ì— ì²´ì´ë‹í•©ë‹ˆë‹¤.` });
                    }
                    table[hash].push(key);
                    steps.push({ state: { table: deepCopy(table) }, log: `${key}ì„(ë¥¼) ${hash}ë²ˆ ì¸ë±ìŠ¤ì— ì‚½ì…(ì²´ì´ë‹)í–ˆìŠµë‹ˆë‹¤.` });
                } else {
                    let i = 0;
                    let currentPos = hash;
                    while (table[currentPos] !== null) {
                        collisionCount++;
                        collisionDetails[currentPos] = (collisionDetails[currentPos] || 0) + 1;
                        steps.push({ state: { table: deepCopy(table), collided: currentPos }, log: `ì¶©ëŒ ë°œìƒ! ${currentPos}ë²ˆ ì¸ë±ìŠ¤ëŠ” ì´ë¯¸ ì‚¬ìš© ì¤‘ì…ë‹ˆë‹¤.` });
                        i++;
                        if (currentAlgorithm === 'linearProbing') {
                            currentPos = (hash + i) % size;
                        } else if (currentAlgorithm === 'quadraticProbing') {
                            currentPos = (hash + i*i) % size;
                        } else if (currentAlgorithm === 'doubleHashing') {
                            const h2 = 5 - (key % 5); // From PDF example
                            currentPos = (hash + i * h2) % size;
                        }
                        steps.push({ state: { table: deepCopy(table), comparing: currentPos }, log: `ë‹¤ìŒ ìœ„ì¹˜ ${currentPos}ì„(ë¥¼) ì¡°ì‚¬í•©ë‹ˆë‹¤.` });
                    }
                    table[currentPos] = key;
                    steps.push({ state: { table: deepCopy(table) }, log: `${key}ì„(ë¥¼) ${currentPos}ë²ˆ ì¸ë±ìŠ¤ì— ì‚½ì…í–ˆìŠµë‹ˆë‹¤.` });
                }
            }
            let summary = `ì´ ${collisionCount}ë²ˆì˜ ì¶©ëŒì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`;
            const details = Object.entries(collisionDetails).map(([idx, count]) => `${idx}ë²ˆ(${count}íšŒ)`).join(', ');
            if (details) {
                summary += ` (ì„¸ë¶€: ${details})`;
            }
            steps.push({ state: { table: deepCopy(table) }, log: `ëª¨ë“  ë°ì´í„° ì‚½ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`, summary: summary });
            return steps;
        }

        // --- Initial Setup ---
        window.onload = () => {
            showPage('home');
            document.querySelectorAll('#sorting-nav .nav-item').forEach(item => {
                item.addEventListener('click', (e) => selectAlgorithm(e.target.dataset.algo));
            });
            document.querySelectorAll('#searching-nav .nav-item').forEach(item => {
                item.addEventListener('click', (e) => selectAlgorithm(e.target.dataset.algo));
            });
        };
    </script>
</body>
</html>
